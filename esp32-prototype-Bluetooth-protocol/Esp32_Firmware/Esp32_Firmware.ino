#include <Ticker.h>
#include <BLEDevice.h>
#include <BLEServer.h>
#include <BLEUtils.h>
#include <BLE2902.h>
#include <esp_task_wdt.h>
#include <driver/dac.h>
#include <esp_timer.h>
#include <cmath>

// Watchdog settings
#define WDT_TIMEOUT_S 10 // Watchdog timeout in seconds

// BLE Setup
BLEServer* pServer = NULL;

// Separate declarations for the two characteristics
BLECharacteristic* pNotesCharacteristic = NULL;    // For musical notes (frequencies)
BLECharacteristic* pVibrationCharacteristic = NULL; // For vibration signals (metronome)

bool deviceConnected = false;
bool oldDeviceConnected = false;

// DAC related variables (using native ESP-IDF DAC driver)
const dac_channel_t DAC_CHANNEL = DAC_CHANNEL_1; // GPIO25 is DAC Channel 1

// FreeRTOS Queue for communicating notes to the DAC task
#define NOTE_QUEUE_LENGTH 5 
#define NOTE_QUEUE_ITEM_SIZE sizeof(int)
QueueHandle_t xNoteQueue; // Queue for note frequencies

// --- GLOBAL VARIABLES FOR VIBRATION AND TONE ---
const int buzzPin = 32; // Pin for the vibration motor
volatile int current_vibration_period_ms = 0; // Period in milliseconds between vibrations (0 for stop)
Ticker vibrationTicker; // Ticker to manage automatic metronome vibration

esp_timer_handle_t vibration_off_timer_handle; // Handle for the timer that turns off vibration
const int ledGreenPin = 5; // Pin for the status LED (green)

#define SINE_WAVE_SAMPLES 32 // Increased for better sound quality
uint8_t sine_wave_table[SINE_WAVE_SAMPLES];
volatile int current_sine_sample_idx = 0; // Current sample index
esp_timer_handle_t dac_timer_handle; // Handle for the DAC timer
volatile int current_note_freq = 0; // Current note frequency (volatile for ISR access)

// Separate UUIDs for the two characteristics (MUST match JavaScript)
#define SERVICE_UUID                  "19b10000-e8f2-537e-4f6c-d104768a1214"
#define NOTES_CHARACTERISTIC_UUID     "39114440-f153-414b-9ca8-cd739acad81c"
#define VIBRATION_CHARACTERISTIC_UUID "19b10002-e8f2-537e-4f6c-d104768a1214"

// --- Function Declarations (forward declarations) ---
void IRAM_ATTR vibration_off_callback(void* arg);
void IRAM_ATTR triggerVibrationBeat();

/**
 * @brief Sets the frequency of the tone generated by the DAC.
 * This function is safe to call from a FreeRTOS task.
 * @param freq The desired frequency in Hz (0 to stop the tone).
 */
void set_note_frequency(int freq) {
    current_note_freq = freq;

    if (freq == 0) { 
        if (esp_timer_is_active(dac_timer_handle)) {
            ESP_ERROR_CHECK(esp_timer_stop(dac_timer_handle));
            dac_output_voltage(DAC_CHANNEL, 0);
            Serial.println("DACTask: DAC timer stopped and output to 0 (sound stopped).");
        }
    } else {
        long timer_period_us = (long)(1000000.0f / (static_cast<float>(freq) * SINE_WAVE_SAMPLES));

        if (timer_period_us <= 0) {
            Serial.print("DACTask: Invalid or too high frequency for timer (");
            Serial.print(freq);
            Serial.println(" Hz).");
            if (esp_timer_is_active(dac_timer_handle)) {
                ESP_ERROR_CHECK(esp_timer_stop(dac_timer_handle));
                dac_output_voltage(DAC_CHANNEL, 0);
            }
            return;
        }
        
        current_sine_sample_idx = 0;

        if (esp_timer_is_active(dac_timer_handle)) {
            ESP_ERROR_CHECK(esp_timer_stop(dac_timer_handle));
        }
        ESP_ERROR_CHECK(esp_timer_start_periodic(dac_timer_handle, timer_period_us));

        Serial.print("DACTask: Tone started at ");
        Serial.print(freq);
        Serial.print(" Hz with timer interval of ");
        Serial.print(timer_period_us);
        Serial.println(" us.");
    }
}

/**
 * @brief DAC timer callback function (ISR-friendly).
 * This function is called periodically by the timer to update the DAC output.
 */
void IRAM_ATTR dac_timer_callback(void* arg) {
  dac_output_voltage(DAC_CHANNEL, sine_wave_table[current_sine_sample_idx]);
  current_sine_sample_idx = (current_sine_sample_idx + 1) % SINE_WAVE_SAMPLES;
}

/**
 * @brief Callback function for the one-shot timer that turns off vibration (ISR-friendly).
 * Called after a short period to deactivate the motor.
 */
void IRAM_ATTR vibration_off_callback(void* arg) {
  digitalWrite(buzzPin, LOW);
}

/**
 * @brief Initializes the sine wave sample table.
 */
void init_sine_wave_table() {
    for (int i = 0; i < SINE_WAVE_SAMPLES; i++) {
        sine_wave_table[i] = (uint8_t)(127 * (sin(i * 2 * M_PI / SINE_WAVE_SAMPLES)) + 128);
    }
    Serial.println("Sine wave table initialized.");
}

/**
 * @brief Function called by the `vibrationTicker` at the start of each beat.
 * Turns on the vibration motor and schedules its turn-off after a fixed pulse.
 */
void IRAM_ATTR triggerVibrationBeat() {
  digitalWrite(buzzPin, HIGH);

  if (esp_timer_is_active(vibration_off_timer_handle)) {
      esp_timer_stop(vibration_off_timer_handle);
  }
  esp_timer_start_once(vibration_off_timer_handle, 100 * 1000); 
}


// --- BLE CALLBACK CLASSES ---

/**
 * @brief Callback for BLE server connection/disconnection events.
 */
class MyServerCallbacks: public BLEServerCallbacks {
  void onConnect(BLEServer* pServerInstance) {
    deviceConnected = true;
    Serial.println("Device Connected to BLE Server.");
    digitalWrite(ledGreenPin, HIGH);
  };

  void onDisconnect(BLEServer* pServerInstance) {
    deviceConnected = false;
    Serial.println("Device Disconnected from BLE Server.");
    digitalWrite(ledGreenPin, LOW);

    int stopNote = 0;
    if (xNoteQueue != NULL) {
      if (xQueueSend(xNoteQueue, &stopNote, 0) != pdPASS) { 
        Serial.println("ERROR: Disconnection - Note queue full or stop send failed!");
      }
    }
    vibrationTicker.detach();
    digitalWrite(buzzPin, LOW);
    current_vibration_period_ms = 0;

    if (esp_timer_is_active(vibration_off_timer_handle)) {
        esp_timer_stop(vibration_off_timer_handle);
    }

    pServerInstance->startAdvertising();
  }
};

/**
 * @brief Callback for write events on the Notes characteristic.
 */
class NotesCharacteristicCallbacks : public BLECharacteristicCallbacks {
  void onWrite(BLECharacteristic* pCharacteristic) {
    uint8_t* pData = pCharacteristic->getData();
    size_t length = pCharacteristic->getLength();

    if (length == 0) {
        Serial.println("Empty NOTE packet received.");
        return;
    }

    if (length == 2) {
        uint16_t received_freq = (static_cast<uint16_t>(pData[1]) << 8) | static_cast<uint16_t>(pData[0]);
        int noteToSend = received_freq;

        if (xNoteQueue != NULL) {
          if (xQueueSend(xNoteQueue, &noteToSend, 0) != pdPASS) { 
            Serial.println("WARNING: Note queue full or send failed! Packet discarded.");
          }
        }
    } else if (length == 1 && pData[0] == 0x00) {
        int stopNote = 0;
        if (xNoteQueue != NULL) {
            if (xQueueSend(xNoteQueue, &stopNote, 0) != pdPASS) {
              Serial.println("WARNING: Stop send queue full or failed! Packet discarded.");
            }
        }
    } else {
        Serial.print("WARNING: NOTE packet with invalid length (");
        Serial.print(length);
        Serial.println(").");
        int stopNote = 0;
        if (xNoteQueue != NULL) {
            xQueueSend(xNoteQueue, &stopNote, 0);
        }
    }
  }
};

/**
 * @brief Callback for write events on the Vibration characteristic.
 * Manages the start, update, and stop of the metronome vibration.
 */
class VibrationCharacteristicCallbacks : public BLECharacteristicCallbacks {
  void onWrite(BLECharacteristic* pCharacteristic) {
    uint8_t* pData = pCharacteristic->getData();
    size_t length = pCharacteristic->getLength();

    if (length == 0) {
        Serial.println("Empty VIBRATION packet received.");
        return;
    }

    if (length == 2) {
        uint16_t received_period_ms = (static_cast<uint16_t>(pData[1]) << 8) | static_cast<uint16_t>(pData[0]);
        current_vibration_period_ms = received_period_ms;

        vibrationTicker.detach();
        digitalWrite(buzzPin, LOW);
        if (esp_timer_is_active(vibration_off_timer_handle)) {
            esp_timer_stop(vibration_off_timer_handle);
        }

        if (current_vibration_period_ms == 0) {
            Serial.println("Vibration command: STOP received (period 0).");
        } else {
            float ticker_delay_s = static_cast<float>(current_vibration_period_ms) / 1000.0f;
            
            if (ticker_delay_s < 0.01) { 
                Serial.println("WARNING: Vibration period too small (<10ms), ignored or forced to stop.");
                return;
            }

            vibrationTicker.attach(ticker_delay_s, triggerVibrationBeat); 
            Serial.print("Vibration command: ON received. Period set to ");
            Serial.print(current_vibration_period_ms);
            Serial.println(" ms.");
        }
    } else {
        Serial.print("WARNING: VIBRATION packet with invalid length (");
        Serial.print(length);
        Serial.println("). Expected 2 bytes for period.");
        vibrationTicker.detach();
        digitalWrite(buzzPin, LOW);
        if (esp_timer_is_active(vibration_off_timer_handle)) {
            esp_timer_stop(vibration_off_timer_handle);
        }
        current_vibration_period_ms = 0;
    }
  }
};

// --- FreeRTOS TASK for DAC ---

/**
 * @brief FreeRTOS task dedicated to receiving and managing musical notes.
 * Fetches frequencies from the queue and passes them to the set_note_frequency function.
 * @param parameter Pointer to data passed to the task (not used here).
 */
void dacTask(void *parameter) {
  int note_freq_to_play = 0;

  Serial.println("DACTask: Adding task to Watchdog.");
  ESP_ERROR_CHECK(esp_task_wdt_add(NULL));
  Serial.println("DACTask: Started and ready to receive notes.");

  const esp_timer_create_args_t timer_args = {
      .callback = &dac_timer_callback,
      .name = "dac_timer"
  };
  ESP_ERROR_CHECK(esp_timer_create(&timer_args, &dac_timer_handle));

  dac_output_enable(DAC_CHANNEL);
  dac_output_voltage(DAC_CHANNEL, 0);

  for(;;) {
    if (xQueueReceive(xNoteQueue, &note_freq_to_play, pdMS_TO_TICKS(50)) == pdPASS) { 
      esp_task_wdt_reset();

      Serial.print("DACTask: Note received from queue: "); 
      Serial.println(note_freq_to_play); 

      set_note_frequency(note_freq_to_play);

    } else {
      esp_task_wdt_reset();
    }
    vTaskDelay(pdMS_TO_TICKS(1));
  }
}

// --- SETUP FUNCTION ---

/**
 * @brief Initial ESP32 setup function.
 * Configures Serial, GPIO, Watchdog, FreeRTOS tasks, and BLE.
 */
void setup() {
  Serial.begin(115200);

  pinMode(ledGreenPin, OUTPUT);
  digitalWrite(ledGreenPin, LOW);

  pinMode(buzzPin, OUTPUT);
  digitalWrite(buzzPin, LOW);
  Serial.print("Buzzer Pin (GPIO ");
  Serial.print(buzzPin);
  Serial.println(") initialized as OUTPUT.");

  Serial.println("Initializing ESP32...");

  init_sine_wave_table();

  Serial.println("Configuring Watchdog Timer...");
  esp_task_wdt_config_t wdt_config = {
    .timeout_ms = WDT_TIMEOUT_S * 1000,
    .idle_core_mask = (1 << portNUM_PROCESSORS) - 1,
    .trigger_panic = true
  };
  ESP_ERROR_CHECK(esp_task_wdt_init(&wdt_config));
  Serial.println("Watchdog Timer initialized.");

  Serial.println("Subscribing main (loop) task to Watchdog...");
  ESP_ERROR_CHECK(esp_task_wdt_add(NULL));
  Serial.println("Main task subscribed.");

  xNoteQueue = xQueueCreate(NOTE_QUEUE_LENGTH, NOTE_QUEUE_ITEM_SIZE);
  if (xNoteQueue == NULL) {
    Serial.println("CRITICAL ERROR: FreeRTOS queue creation failed. Halting.");
    while(true);
  } else {
    Serial.print("FreeRTOS queue created successfully. Length: ");
    Serial.println(NOTE_QUEUE_LENGTH);
  }

  xTaskCreatePinnedToCore(
    dacTask,
    "DACTask",
    8192,
    NULL,
    5,
    NULL,
    1
  );
  Serial.println("DAC FreeRTOS task created on Core 1 with priority 5."); 

  const esp_timer_create_args_t vib_off_timer_args = {
      .callback = &vibration_off_callback,
      .name = "vib_off_timer"
  };
  ESP_ERROR_CHECK(esp_timer_create(&vib_off_timer_args, &vibration_off_timer_handle));
  Serial.println("One-Shot Timer for vibration turn-off initialized.");

  BLEDevice::init("Assistant");
  esp_ble_tx_power_set(ESP_BLE_PWR_TYPE_DEFAULT, ESP_PWR_LVL_P9); 
  Serial.println("BLE Tx Power set to P9 (+9dBm).");

  pServer = BLEDevice::createServer();
  pServer->setCallbacks(new MyServerCallbacks());

  BLEService *pService = pServer->createService(SERVICE_UUID);

  pNotesCharacteristic = pService->createCharacteristic(
                                NOTES_CHARACTERISTIC_UUID,
                                BLECharacteristic::PROPERTY_WRITE_NR
                            );
  pNotesCharacteristic->setCallbacks(new NotesCharacteristicCallbacks());
  pNotesCharacteristic->addDescriptor(new BLE2902());

  pVibrationCharacteristic = pService->createCharacteristic(
                                VIBRATION_CHARACTERISTIC_UUID,
                                BLECharacteristic::PROPERTY_WRITE_NR
                            );
  pVibrationCharacteristic->setCallbacks(new VibrationCharacteristicCallbacks());
  pVibrationCharacteristic->addDescriptor(new BLE2902());

  pService->start();

  BLEAdvertising *pAdvertising = BLEDevice::getAdvertising();
  pAdvertising->addServiceUUID(SERVICE_UUID);
  pAdvertising->setScanResponse(true);
  pAdvertising->setMinPreferred(0x06);
  pAdvertising->setMinPreferred(0x12); 
  BLEDevice::startAdvertising();
  Serial.println("Device advertising, waiting for connection...");
}

// --- MAIN LOOP ---

/**
 * @brief Main ESP32 loop function.
 * Manages Watchdog reset and connection/disconnection status.
 */
void loop() {
  esp_task_wdt_reset();

  if (!deviceConnected && oldDeviceConnected) {
    Serial.println("Loop: Device disconnected. Restarting Advertising.");
    digitalWrite(ledGreenPin, LOW);
    
    int stopNote = 0;
    if (xNoteQueue != NULL) {
      xQueueSend(xNoteQueue, &stopNote, 0); 
    }
    oldDeviceConnected = deviceConnected;
  }

  if (deviceConnected && !oldDeviceConnected) {
    Serial.println("Loop: Device connected.");
    digitalWrite(ledGreenPin, HIGH);
    oldDeviceConnected = deviceConnected;
  }
  
  vTaskDelay(pdMS_TO_TICKS(1));
}